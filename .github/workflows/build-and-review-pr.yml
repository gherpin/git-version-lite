name: Build and Review PR
run-name: 'Build and Review PR #${{ github.event.pull_request.number }}'

on:
  # https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token
  #
  # This workflow uses the pull_request trigger which prevents write permissions on the
  # GH_TOKEN and secrets access from public forks.  This should remain as a pull_request
  # trigger to minimize the access public forks have in the repository.  The reduced
  # permissions are adequate but do mean that re-compiles and readme changes will have to be
  # made manually by the PR author.  These auto-updates could be done by this workflow
  # for branches but in order to re-trigger a PR build (which is needed for status checks),
  # we would make the commits with a different user and their PAT.  To minimize exposure
  # and complication we will request those changes be manually made by the PR author.
  pull_request:
    types: [opened, synchronize, reopened]
  # paths:
  #   Do not include specific paths here.  We always want this build to run and produce a
  #   status check which are branch protection rules can use.  If this is skipped because of
  #   path filtering, a status check will not be created and we won't be able to merge the PR
  #   without disabling that requirement.  If we have a status check that is always produced,
  #   we can also use that to require all branches be up to date before they are merged.

# -------------------------------------------------------------------------------------
# NOTE: This repo duplicates the reusable build-and-review workflow in im-open/.github
#       that the rest of the actions use.  If changes are needed in this workflow the
#       same changes should be made in im-open/.github.  This workflow is duplicated
#       so it can use a local copy of itself in the workflow.  This allows us to test
#       the build pipeline with git-version-lite changes before we merge those changes.
# -------------------------------------------------------------------------------------

jobs:
  test-general:
    runs-on: ubuntu-latest

    env:
      # These env variables are set by git-version-lite
      PRIOR_VERSION: ''
      NEXT_VERSION: ''
      NEXT_MINOR_VERSION: ''
      NEXT_MAJOR_VERSION: ''
      PRIOR_VERSION_NO_PREFIX: ''
      NEXT_VERSION_NO_PREFIX: ''
      NEXT_MINOR_VERSION_NO_PREFIX: ''
      NEXT_MAJOR_VERSION_NO_PREFIX: ''

      # Info for the repo we'll be testing git-version-lite against
      TESTING_REPO: 'im-open/internal-repo-for-testing-purple-actions'
      
      # These is based on the fetch-depth not being set. git-version-lite starts from 0.0.0 when calculating the next version
      PRIOR_TAG: '0.0.0'

      # This will be the next set of tags if it falls back to using the un-prefixed tag on the repo
      PRIOR_TAG_FOR_FALLBACK: '1.1.0'
      NEXT_PATCH_TAG_FOR_FALLBACK: '1.1.1'
      NEXT_MINOR_TAG_FOR_FALLBACK: '1.1'
      NEXT_MAJOR_TAG_FOR_FALLBACK: '1'

    steps:
      #--------------------------------------
      # SETUP
      #--------------------------------------
      - name: Fail test job if fork
        run: |
          if [ "${{ github.event.pull_request.head.repo.fork }}" == "true" ]; then
            echo "This test job requires secrets that PRs from forks will not have access to.  Before this PR can be merged, the tests should be run on an intermediate branch created by repository owners."
            exit 1
          fi

      - name: '-------------------------------------------------------------------------------------------------------'
        run: echo ""

      - name: Setup - Checkout testing repo in the root directory
        if: always()
        uses: actions/checkout@v4
        with:
          ref: main
          repository: ${{ env.TESTING_REPO }}
          ssh-key: ${{ secrets.SSH_KEY_TESTING_REPO }}
          # fetch-depth: 0  # Do not use this because we want to test what happens when fetch-depth is not set

      - name: Setup - Checkout this action (git-version-lite) into a 'gvl' subdirectory
        if: always()
        uses: actions/checkout@v3
        with:
          path: ./gvl

      - name: Setup - List directories
        if: always()
        run: |
          echo -e "\nRoot directory contents:"
          ls -a

          echo -e "\ngit-version-lite (gvl) contents:"
          ls -a ./gvl

      #--------------------------------------
      # UNEXPECTED RELEASE TYPE
      #--------------------------------------
      - name: '-------------------------------------------------------------------------------------------------------'
        run: echo ""

      - name: When a new version is requested with an unexpected default release type
        if: always()
        uses: ./gvl
        id: unexpected-release-type
        continue-on-error: true # This is needed because we expect the step to fail.  We need it to "pass" in order for the test job to succeed.
        with:
          default-release-type: 'unexpected'
          # calculate-prerelease-version: false
          # branch-name: ''
          # tag-prefix: v
          # fallback-to-no-prefix-search: true

      - name: Then the outcome should be failure
        if: always()
        run: ./gvl/test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.unexpected-release-type.outcome }}"

      - name: Then the outputs should be empty
        if: always()
        run: |
          ./gvl/test/assert-values-match.sh --name "PRIOR_VERSION output" --expected "" --actual "${{ steps.unexpected-release-type.outputs.PRIOR_VERSION }}"
          ./gvl/test/assert-values-match.sh --name "PRIOR_VERSION_NO_PREFIX output" --expected "" --actual "${{ steps.unexpected-release-type.outputs.PRIOR_VERSION_NO_PREFIX }}"
          ./gvl/test/assert-values-match.sh --name "NEXT_VERSION output" --expected "" --actual "${{ steps.unexpected-release-type.outputs.NEXT_VERSION }}"
          ./gvl/test/assert-values-match.sh --name "NEXT_VERSION_NO_PREFIX output" --expected "" --actual "${{ steps.unexpected-release-type.outputs.NEXT_VERSION_NO_PREFIX }}"
          ./gvl/test/assert-values-match.sh --name "NEXT_MINOR_VERSION output" --expected "" --actual "${{ steps.unexpected-release-type.outputs.NEXT_MINOR_VERSION }}"
          ./gvl/test/assert-values-match.sh --name "NEXT_MINOR_VERSION_NO_PREFIX output" --expected "" --actual "${{ steps.unexpected-release-type.outputs.NEXT_MINOR_VERSION_NO_PREFIX }}"
          ./gvl/test/assert-values-match.sh --name "NEXT_MAJOR_VERSION output" --expected "" --actual "${{ steps.unexpected-release-type.outputs.NEXT_MAJOR_VERSION }}"
          ./gvl/test/assert-values-match.sh --name "NEXT_MAJOR_VERSION_NO_PREFIX output" --expected "" --actual "${{ steps.unexpected-release-type.outputs.NEXT_MAJOR_VERSION_NO_PREFIX }}"

      - name: And the environment variables should be empty
        if: always()
        run: |
          ./gvl/test/assert-values-match.sh --name "PRIOR_VERSION env" --expected "" --actual "${{ env.PRIOR_VERSION }}"
          ./gvl/test/assert-values-match.sh --name "PRIOR_VERSION_NO_PREFIX env" --expected "" --actual "${{ env.PRIOR_VERSION_NO_PREFIX }}"
          ./gvl/test/assert-values-match.sh --name "NEXT_VERSION env" --expected "" --actual "${{ env.NEXT_VERSION }}"
          ./gvl/test/assert-values-match.sh --name "NEXT_VERSION_NO_PREFIX env" --expected "" --actual "${{ env.NEXT_VERSION_NO_PREFIX }}"
          ./gvl/test/assert-values-match.sh --name "NEXT_MINOR_VERSION env" --expected "" --actual "${{ env.NEXT_MINOR_VERSION }}"
          ./gvl/test/assert-values-match.sh --name "NEXT_MINOR_VERSION_NO_PREFIX env" --expected "" --actual "${{ env.NEXT_MINOR_VERSION_NO_PREFIX }}"
          ./gvl/test/assert-values-match.sh --name "NEXT_MAJOR_VERSION env" --expected "" --actual "${{ env.NEXT_MAJOR_VERSION }}"
          ./gvl/test/assert-values-match.sh --name "NEXT_MAJOR_VERSION_NO_PREFIX env" --expected "" --actual "${{ env.NEXT_MAJOR_VERSION_NO_PREFIX }}"

      #--------------------------------------
      # FALLBACK TO NO PREFIX
      #--------------------------------------
      - name: '-------------------------------------------------------------------------------------------------------'
        run: echo ""

      - name: When a repo has all of its tags locally
        run: |
          git rev-parse --abbrev-ref HEAD
          git log --graph --decorate

          git pull
          git fetch -t
          git log --graph --decorate

          

      - name: And a new version is requested with fallback-to-no-prefix set
        if: always()
        uses: ./gvl
        id: fallback
        continue-on-error: true # This is needed because we expect the step to fail.  We need it to "pass" in order for the test job to succeed.
        with:
          # This prefix won't match anything but it should fall back to searching with no prefix (there will be one at 1.1.0)
          tag-prefix: qbdb
          fallback-to-no-prefix-search: true

      - name: Then the outcome should be success
        if: always()
        run: ./gvl/test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.fallback.outcome }}"

      - name: Then the outputs should be based on the no-prefix patch increment
        if: always()
        run: |
          prefix="qbdb"
          prior="${{ env.PRIOR_TAG_FOR_FALLBACK }}"
          patch="${{ env.NEXT_PATCH_TAG_FOR_FALLBACK}}"
          minor="${{ env.NEXT_MINOR_TAG_FOR_FALLBACK}}"
          major="${{ env.NEXT_MAJOR_TAG_FOR_FALLBACK}}"

          ./gvl/test/assert-values-match.sh --name "PRIOR_VERSION"      --expected "$prefix$prior" --actual "${{ steps.fallback.outputs.PRIOR_VERSION }}"
          ./gvl/test/assert-values-match.sh --name "NEXT_VERSION"       --expected "$prefix$patch" --actual "${{ steps.fallback.outputs.NEXT_VERSION }}"
          ./gvl/test/assert-values-match.sh --name "NEXT_MINOR_VERSION" --expected "$prefix$minor" --actual "${{ steps.fallback.outputs.NEXT_MINOR_VERSION }}"
          ./gvl/test/assert-values-match.sh --name "NEXT_MAJOR_VERSION" --expected "$prefix$major" --actual "${{ steps.fallback.outputs.NEXT_MAJOR_VERSION }}"

          ./gvl/test/assert-values-match.sh --name "PRIOR_VERSION_NO_PREFIX"      --expected "$prior" --actual "${{ steps.fallback.outputs.PRIOR_VERSION_NO_PREFIX }}"
          ./gvl/test/assert-values-match.sh --name "NEXT_VERSION_NO_PREFIX"       --expected "$patch" --actual "${{ steps.fallback.outputs.NEXT_VERSION_NO_PREFIX }}"
          ./gvl/test/assert-values-match.sh --name "NEXT_MINOR_VERSION_NO_PREFIX" --expected "$minor" --actual "${{ steps.fallback.outputs.NEXT_MINOR_VERSION_NO_PREFIX }}"
          ./gvl/test/assert-values-match.sh --name "NEXT_MAJOR_VERSION_NO_PREFIX" --expected "$major" --actual "${{ steps.fallback.outputs.NEXT_MAJOR_VERSION_NO_PREFIX }}"

      - name: And the environment variables should be based on the no-prefix patch increment
        if: always()
        run: |
          prefix="qbdb"
          prior="${{ env.PRIOR_TAG_FOR_FALLBACK }}"
          patch="${{ env.NEXT_PATCH_TAG_FOR_FALLBACK}}"
          minor="${{ env.NEXT_MINOR_TAG_FOR_FALLBACK}}"
          major="${{ env.NEXT_MAJOR_TAG_FOR_FALLBACK}}"

          ./gvl/test/assert-values-match.sh --name "PRIOR_VERSION"      --expected "$prefix$prior" --actual "${{ env.PRIOR_VERSION }}"
          ./gvl/test/assert-values-match.sh --name "NEXT_VERSION"       --expected "$prefix$patch" --actual "${{ env.NEXT_VERSION }}"
          ./gvl/test/assert-values-match.sh --name "NEXT_MINOR_VERSION" --expected "$prefix$minor" --actual "${{ env.NEXT_MINOR_VERSION }}"
          ./gvl/test/assert-values-match.sh --name "NEXT_MAJOR_VERSION" --expected "$prefix$major" --actual "${{ env.NEXT_MAJOR_VERSION }}"

          ./gvl/test/assert-values-match.sh --name "PRIOR_VERSION_NO_PREFIX"      --expected "$prior" --actual "${{ env.PRIOR_VERSION_NO_PREFIX }}"
          ./gvl/test/assert-values-match.sh --name "NEXT_VERSION_NO_PREFIX"       --expected "$patch" --actual "${{ env.NEXT_VERSION_NO_PREFIX }}"
          ./gvl/test/assert-values-match.sh --name "NEXT_MINOR_VERSION_NO_PREFIX" --expected "$minor" --actual "${{ env.NEXT_MINOR_VERSION_NO_PREFIX }}"
          ./gvl/test/assert-values-match.sh --name "NEXT_MAJOR_VERSION_NO_PREFIX" --expected "$major" --actual "${{ env.NEXT_MAJOR_VERSION_NO_PREFIX }}"

 